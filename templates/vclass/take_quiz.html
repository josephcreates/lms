{% extends 'vclass/base_vclass.html' %}
{% block title %}Take Quiz – {{ quiz_json.title }}{% endblock %}

{% block content %}
<div class="container-fluid py-4 v-quiz">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h4 id="quiz-title" class="mb-0">{{ quiz_json.title }}</h4>

    <!-- TIMER -->
    <div class="text-end">
      <div id="timer-wrapper" role="timer" aria-atomic="true" aria-live="polite" class="small text-muted">
        <div><strong>Time Left:</strong></div>
        <div id="timer" class="fw-bold fs-5 text-danger" aria-label="Time remaining">--:--</div>
      </div>
    </div>
  </div>

  <!-- progress / summary -->
  <div class="row mb-3 gx-3">
    <div class="col-lg-8">
      <div class="progress mb-2" id="progress-bar" role="progressbar"
           aria-valuemin="0" aria-valuemax="{{ quiz_json.questions|length }}" aria-valuenow="0"
           style="height:28px; background:#e9f7ee;">
        <div id="progress-inner" class="progress-bar" style="width:0%; display:flex; align-items:center; justify-content:center; background:var(--v-accent);">
          <span id="progress-text">0/{{ quiz_json.questions|length }} (0%)</span>
        </div>
      </div>
    </div>

    <div class="col-lg-4 text-lg-end">
      <div class="d-inline-block me-3">
        <div class="small text-muted">Total</div>
        <div id="summary-total" class="fw-bold">{{ quiz_json.questions|length }}</div>
      </div>
      <div class="d-inline-block me-3">
        <div class="small text-muted">Answered</div>
        <div id="summary-answered" class="fw-bold">0</div>
      </div>
      <div class="d-inline-block">
        <div class="small text-muted">Unanswered</div>
        <div id="summary-unanswered" class="fw-bold">{{ quiz_json.questions|length }}</div>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- questions -->
    <div class="col-lg-9">
      <form id="quiz-form" method="POST" action="{{ url_for('vclass.submit_quiz', quiz_id=quiz_json.id) }}">
          <!-- or if you want explicit input -->
          <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div id="questions-container" class="mb-4" aria-live="polite"></div>

        <nav class="mt-2" aria-label="Quiz Navigation">
          <ul class="pagination justify-content-center" id="pagination"></ul>
        </nav>

        <div id="submit-container" class="text-end mt-3">
          <button type="submit" class="btn btn-success" id="submit-btn">Submit Quiz</button>
        </div>
      </form>
    </div>

    <!-- palette -->
    <aside class="col-lg-3">
      <div class="card shadow-sm">
        <div class="card-body">
          <h6 class="card-title mb-2">Question Palette</h6>
          <div class="small text-muted mb-2">Click a number to jump to that question. Green = answered.</div>
          <div id="question-palette" class="d-grid gap-2" style="grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));"></div>

          <div class="mt-3 small text-muted">
            Legend:
            <span class="badge bg-success me-1">Answered</span>
            <span class="badge bg-light border text-dark me-1">Unanswered</span>
            <span class="badge" style="background:var(--v-accent); color:#fff;">Current</span>
          </div>
        </div>
      </div>
    </aside>
  </div>
</div>

{# embed quiz JSON safely #}
<script id="quiz-data" type="application/json">{{ quiz_json | tojson }}</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const quiz = JSON.parse(document.getElementById("quiz-data").textContent);
  const quizId = quiz.id;
  const duration = (quiz.duration_minutes || 0) * 60; // seconds
  const perPage = 5;
  const totalQuestions = quiz.questions.length;
  const totalPages = Math.max(1, Math.ceil(totalQuestions / perPage));

  // UI refs
  let currentPage = 1;
  let answers = {};           // { questionId: optionId }
  const timerEl = document.getElementById("timer");
  const questionsContainer = document.getElementById("questions-container");
  const paginationEl = document.getElementById("pagination");
  const progressInner = document.getElementById("progress-inner");
  const progressText = document.getElementById("progress-text");
  const summaryAnswered = document.getElementById("summary-answered");
  const summaryUnanswered = document.getElementById("summary-unanswered");
  const paletteEl = document.getElementById("question-palette");
  const form = document.getElementById("quiz-form");

  // CSRF: prefer meta tag, fallback to hidden input
  // prefer meta tag, fallback to hidden input
function getMetaCsrf() {
  const m = document.querySelector('meta[name="csrf-token"]');
  if (m && m.content) return m.content;
  const hidden = document.querySelector('input[name="csrf_token"]');
  return hidden ? hidden.value : '';
}
const csrfToken = getMetaCsrf() || '';
// expose globally for other helpers that expect window.csrfToken
window.csrfToken = csrfToken;

async function csrfFetch(url, options = {}) {
  options = options || {};
  options.headers = options.headers || {};

  // if not FormData and not explicitly set, send JSON header
  if (options.body && !(options.body instanceof FormData) && !options.headers['Content-Type']) {
    options.headers["Content-Type"] = "application/json";
  }

  // Send token in both common header names (some libs expect one or the other)
  if (csrfToken) {
    options.headers["X-CSRFToken"] = csrfToken;
    options.headers["X-CSRF-Token"] = csrfToken;
  }

  // ensure cookies are sent to the server
  options.credentials = options.credentials || "include";

  return fetch(url, options);
}

  // session start time injected from server; ensure same format. If empty, server will be asked to start the timer.
  const startStr = "{{ session.get('quiz_' ~ quiz_json.id ~ '_start_time','')[:19] }}Z";
  let startTime = startStr ? new Date(startStr) : null;

  const LS_KEY = `vclass_quiz_answers_${quizId}`;

  // debounce helper
  const debounce = (fn, wait = 300) => {
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  };

  // autosave (debounced network call)
  const autosaveNetwork = debounce(async (qid, oid) => {
    try {
      await csrfFetch("{{ url_for('vclass.autosave_answer', ) }}", {
        method: "POST",
        body: JSON.stringify({ quiz_id: quizId, question_id: qid, selected_option_id: oid })
      });
    } catch (err) {
      console.warn("Autosave failed (network):", err);
    }
  }, 300);

  function saveAnswer(qid, oid) {
    answers[qid] = oid;
    try { localStorage.setItem(LS_KEY, JSON.stringify(answers)); } catch (e) { /* ignore */ }
    autosaveNetwork(qid, oid);
  }

  (async function initializeFlow() {
    try {
      // use rendered URL with actual quiz id
      const submittedRes = await csrfFetch('{{ url_for("vclass.has_submitted", quiz_id=quiz_json.id) }}', { method: "GET" });
      if (submittedRes.ok) {
        const submittedJson = await submittedRes.json();
        if (submittedJson.submitted) {
          window.location.href = "{{ url_for('vclass.dashboard') }}";
          return;
        }
      }
    } catch (err) { console.warn("has-submitted check failed:", err); }

    // if startTime missing -> request server to start timer then reload
    if (!startTime || isNaN(startTime.getTime())) {
      try {
        const startRes = await csrfFetch('{{ url_for("vclass.start_quiz_timer", quiz_id=quiz_json.id) }}', { method: "POST", body: JSON.stringify({}) });
        if (startRes.ok) return window.location.reload();
        alert("Unable to start quiz timer. Please try again.");
        return;
      } catch (err) {
        console.error("Failed to start timer:", err);
        alert("Unable to start quiz timer due to network error. Please reload.");
        return;
      }
    }

    // restore answers from server, fallback to localStorage
    try {
      const res = await csrfFetch('{{ url_for("vclass.get_saved_answers", quiz_id=quiz_json.id) }}', { method: "GET" });
      if (res.ok) {
        const serverAnswers = await res.json();
        if (serverAnswers && Object.keys(serverAnswers).length) {
          answers = serverAnswers;
        } else {
          const ls = localStorage.getItem(LS_KEY);
          if (ls) answers = JSON.parse(ls) || {};
        }
      } else {
        const ls = localStorage.getItem(LS_KEY);
        if (ls) answers = JSON.parse(ls) || {};
      }
    } catch (err) {
      console.warn("Failed to fetch saved answers:", err);
      const ls = localStorage.getItem(LS_KEY);
      if (ls) answers = JSON.parse(ls) || {};
    }

    init();
  })();

  /* UI render & helpers */
  function init() {
    renderPalette();
    renderQuestions(currentPage);
    renderPagination();
    updateProgress();
    startCountdown();
  }

  function renderPalette() {
  paletteEl.innerHTML = '';
  for (let i = 0; i < totalQuestions; i++) {
    const q = quiz.questions[i];
    const btn = document.createElement('button');
    btn.type = 'button';
    // use a small semantic class 'palette-btn' + state classes
    btn.className = 'btn btn-sm border palette-btn unanswered';
    btn.style.minHeight = '40px';
    btn.style.minWidth = '42px';
    btn.setAttribute('data-idx', i);
    btn.setAttribute('aria-label', `Question ${i + 1}`);
    btn.textContent = i + 1;

    // mark answered initially
    if (answers[q.id]) {
      btn.classList.remove('unanswered');
      btn.classList.add('answered');
      btn.setAttribute('aria-pressed', 'true');
    } else {
      btn.setAttribute('aria-pressed', 'false');
    }

    btn.addEventListener('click', () => {
      const page = Math.floor(i / perPage) + 1;
      renderQuestions(page);
      setTimeout(() => {
        const first = document.querySelector('#questions-container input');
        if (first) first.focus();
      }, 40);
    });

    paletteEl.appendChild(btn);
  }
  updatePalette();
}

function updatePalette() {
  const buttons = Array.from(paletteEl.querySelectorAll('button'));
  const curStart = (currentPage - 1) * perPage;
  const curEnd = curStart + perPage - 1;

  buttons.forEach((btn, idx) => {
    const q = quiz.questions[idx];

    // remove any previous 'current' marker
    btn.classList.remove('current');

    // answered / unanswered state (keeps classes deterministic)
    if (answers[q.id]) {
      btn.classList.remove('unanswered');
      btn.classList.add('answered');
      btn.setAttribute('aria-pressed', 'true');
    } else {
      btn.classList.remove('answered');
      btn.classList.add('unanswered');
      btn.setAttribute('aria-pressed', 'false');
    }

    // mark visible page as current
    if (idx >= curStart && idx <= curEnd) {
      btn.classList.add('current');
    } else {
      btn.classList.remove('current');
    }
  });

  // update summary/progress numbers
  const answeredCount = Object.keys(answers).length;
  summaryAnswered.textContent = answeredCount;
  summaryUnanswered.textContent = Math.max(0, totalQuestions - answeredCount);
  const progressbar = document.getElementById("progress-bar");
  progressbar.setAttribute('aria-valuenow', answeredCount);
  progressbar.setAttribute('aria-valuemax', totalQuestions);
}

  function renderQuestions(page) {
    currentPage = page;
    questionsContainer.innerHTML = '';
    const start = (page - 1) * perPage;
    const end = Math.min(start + perPage, totalQuestions);

    for (let i = start; i < end; i++) {
      const q = quiz.questions[i];
      const block = document.createElement('div');
      block.className = 'mb-3 p-3 border rounded';
      block.innerHTML = `<div class="mb-2"><strong>Question ${i+1}:</strong></div><div class="mb-2">${q.question_text}</div>`;

      q.options.forEach(opt => {
        const optId = `q${q.id}_o${opt.id}`;
        const wrap = document.createElement('div');
        wrap.className = 'form-check';

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = `answers[${q.id}]`;
        radio.id = optId;
        radio.value = opt.id;
        radio.className = 'form-check-input';
        radio.setAttribute('data-qid', q.id);

        if (answers[q.id] && String(answers[q.id]) === String(opt.id)) radio.checked = true;

        radio.addEventListener('change', (e) => {
          answers[q.id] = opt.id;
          saveAnswer(q.id, opt.id);
          updateProgress();
          updatePalette();
        });

        const label = document.createElement('label');
        label.htmlFor = optId;
        label.className = 'form-check-label';
        label.innerHTML = opt.text;

        wrap.appendChild(radio);
        wrap.appendChild(label);
        block.appendChild(wrap);
      });

      questionsContainer.appendChild(block);
    }
    renderPagination();
    updatePalette();
  }

  function renderPagination() {
    paginationEl.innerHTML = '';
    const makeLi = (pageNum, text, disabled=false, active=false) => {
      const li = document.createElement('li');
      li.className = 'page-item' + (disabled ? ' disabled' : '') + (active ? ' active' : '');
      const pageStartIdx = (pageNum - 1) * perPage;
      const q = quiz.questions[pageStartIdx];
      if (answers[q?.id]) li.classList.add('bg-success','text-white');

      const a = document.createElement('a');
      a.className = 'page-link';
      a.href = '#';
      a.textContent = text || pageNum;
      a.addEventListener('click', (e) => { e.preventDefault(); if (!disabled) renderQuestions(pageNum); });
      li.appendChild(a);
      return li;
    };

    paginationEl.appendChild(makeLi(currentPage - 1, '« Prev', currentPage === 1));
    for (let p = 1; p <= totalPages; p++) paginationEl.appendChild(makeLi(p, null, false, p === currentPage));
    paginationEl.appendChild(makeLi(currentPage + 1, 'Next »', currentPage === totalPages));
  }

  function updateProgress() {
    const answeredCount = Object.keys(answers).length;
    const percent = totalQuestions ? Math.round((answeredCount / totalQuestions) * 100) : 0;
    progressInner.style.width = percent + '%';
    progressText.textContent = `${answeredCount}/${totalQuestions} (${percent}%)`;
    document.getElementById("progress-bar").setAttribute('aria-valuenow', answeredCount);
  }

  // Inject answers into form before submit
  function injectAnswersIntoForm() {
    // remove previous generated hidden fields
    document.querySelectorAll('input[name^="answers["][type="hidden"]').forEach(n => n.remove());
    Object.entries(answers).forEach(([qid, oid]) => {
      const hidden = document.createElement('input');
      hidden.type = 'hidden';
      hidden.name = `answers[${qid}]`;
      hidden.value = oid;
      form.appendChild(hidden);
    });
  }

  function ensureCsrfInput() {
    if (!document.querySelector('input[name="csrf_token"]')) {
      const csrf = document.createElement('input');
      csrf.type = 'hidden';
      csrf.name = 'csrf_token';
      csrf.value = window.csrfToken || '';
      form.appendChild(csrf);
    }
  }

  form.addEventListener('submit', (e) => {
    const unanswered = totalQuestions - Object.keys(answers).length;
    if (unanswered > 0 && !confirm(`You have ${unanswered} unanswered question(s). Submit anyway?`)) {
      e.preventDefault();
      return;
    }
    injectAnswersIntoForm();
    ensureCsrfInput();
    // allow default submit to server
  });

  /* Timer */
  function startCountdown() {
    if (!startTime || isNaN(startTime.getTime())) {
      console.error("invalid startTime", startTime);
      alert("Quiz start time is invalid. Please reload.");
      return;
    }
    const tick = () => {
      const now = new Date();
      const elapsed = Math.floor((now - startTime) / 1000);
      const left = duration - elapsed;
      if (left <= 0) {
        timerEl.textContent = "00:00";
        document.querySelectorAll("#quiz-form input, #quiz-form button").forEach(el => el.disabled = true);
        // auto-submit after short pause
        setTimeout(() => {
          injectAnswersIntoForm();
          ensureCsrfInput();
          form.submit();
        }, 600);
        return;
      }
      timerEl.textContent = formatTime(left);
      document.getElementById('timer-wrapper').setAttribute('aria-label', 'Time remaining ' + timerEl.textContent);
      setTimeout(tick, 1000);
    };
    tick();
  }

  function formatTime(sec) {
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = sec % 60;
    if (h > 0) return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

});
</script>

<style>
/* palette & buttons tuned to vclass look */
/* palette & buttons tuned to vclass look (robust custom classes) */
#question-palette .palette-btn {
  border-radius: 6px;
  min-width: 42px;
  min-height: 42px;
  font-weight: 700;
  padding: 6px 8px;
  transition: background .18s ease, transform .12s ease, box-shadow .12s ease;
}

/* Unanswered: light background */
#question-palette .palette-btn.unanswered {
  background-color: #f8f9fa;
  color: #212529;
  border-color: rgba(0,0,0,0.06);
}

/* Answered: green */
#question-palette .palette-btn.answered {
  background-color: #198754;
  color: #fff;
  border-color: #198754;
}

/* Current (visible page): accent color */
#question-palette .palette-btn.current {
  background-color: var(--v-accent, #0d6efd);
  color: #fff;
  box-shadow: 0 6px 18px rgba(13,110,253,0.12);
  transform: translateY(-2px);
}

/* ensure contrast for current+answered when they coincide */
#question-palette .palette-btn.current.answered {
  /* keep current accent visually prominent */
  background-color: var(--v-accent, #0d6efd);
  border-color: var(--v-accent, #0d6efd);
}

/* small focus/hover affordances */
#question-palette .palette-btn:focus,
#question-palette .palette-btn:hover {
  outline: none;
  filter: brightness(0.96);
}
.progress-bar { transition: width .4s ease; }
</style>
{% endblock %}
